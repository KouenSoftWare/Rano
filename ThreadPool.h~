#pragma once

#include "Event.h"

#define IN 0
#define OUT 1
#define ERROR 2

class ThreadPool
{
private:
	boost::lockfree::queue<Event*> (&queues_)[3];
	int threadCount_;
	bool looping_;

	vector<boost::thread*> vecpThrd_;
	map<string, FuncPtr> eventFunctionList_;
	map<string, boost::shared_ptr<EventFactory> > eventFactory_;
public:
	ThreadPool(int threadCount, boost::lockfree::queue<Event*> (&queues)[3]):
		queues_(queues),
		threadCount_(threadCount),
		looping_(true){
	}
	
	void start(){
		boost::function0<void> f = boost::bind(&ThreadPool::Run, this);
		for (int i = 0; i < threadCount_; i++){
			boost::thread* thrd = new boost::thread(f);
			vecpThrd_.push_back(thrd);
		}
	}

	void reg(string name, FuncPtr f){
		eventFunctionList_.insert(pair<string, FuncPtr>(name, f));
	}

	boost::shared_ptr<EventFactory> getFactroy(string name){
		return eventFactory_.find(name)->second;
	}

	void reg(string name, boost::shared_ptr<EventFactory>& factory){
		eventFactory_.insert(pair<string, boost::shared_ptr<EventFactory> >(name, factory));
	}

	~ThreadPool(){
		for (int i = 0; i < threadCount_; i++){
			vecpThrd_[i]->join();
		}
	}

	void shutdown(){
		looping_ = false;
	}

	void push(int Option, Event *e);

	void Run();
};
